<head>
<link type="text/css" rel="stylesheet" href="mperdikeasgithub.css"/>
</head>
<body>
<ol reversed>
<li>how to install <b>pgsphere</b></li>
I followed the instructions from <a href="http://pgsphere.projects.pgfoundry.org">the pgSphere 1.1 project site</a>
with the following qualifications and log:
    <ol type="i">
    <li>downloaded pgSphere sources from <a href="http://pgfoundry.org/projects/pgsphere/">the pgSphere homepage</a></li>
    <pre>
    wget http://pgfoundry.org/frs/download.php/2558/pgsphere-1.1.1.tar.gz
    </pre>
    <li>I opted for the <i>second way</i> to compile <b>pgSphere</b> (as instructed in <a href="http://pgsphere.projects.pgfoundry.org/x44.html">the installation instructions page</a>), which is the one that does not require the PostgreSQL sources but, instead, the configuration tool <b>pg_config</b></li>
    <li>since <b>pg_config</b> didn't exist I installed it by executing:
        <pre>
sudo apt-cache search postgresql-server-dev
sudo apt-get install postgresql-server-dev-9.1
        </pre>
        Now, <b>pg_config</b> is installed and its location can be got with:<pre>which pg_config</pre> (we use that location below)
    </li>
    <li>expand the pgSphere tarball we downloaded and cd into the directory that's created:
    <pre>
tar xvfz pgsphere-1.1.1.tar.gz
cd pgsphere-1.1.1/
    </pre>
    </li>
    <li>follow the installation instructions linked above ("<i>second way</i>"), replacing "/path/to/pg_config" with the actual path</li>
    <pre>
make USE_PGXS=1 PG_CONFIG=/usr/bin/pg_config
sudo make USE_PGXS=1 PG_CONFIG=/usr/bin/pg_config install
    </pre>
    <li>when I tried to check the installation as instructed:
    <br/><br/><i>To check the installation change into the pg_sphere source directory again and run:
<br/>
shell> make installcheck
</i><br/><br/>... I got the following error trace:
<pre>
Makefile:29: ../../src/Makefile.global: No such file or directory
Makefile:30: /contrib/contrib-global.mk: No such file or directory
make: *** No rule to make target `/contrib/contrib-global.mk'.  Stop.
</pre>
    ... but the installation was successful nonetheless because I was able to execute the last step as
advised in "<i>2.3. Creating a database with pgSphere</i>" of the installation instructions linked above with:
<pre>
psql -U postgres -d RegTAP -f ./pg_sphere.sql
</pre>
    </ol>
<li>Window functions (cont.)</li>
Note that <b>PARTITION</b> is not the function to be used in the <b>OVER</b> clause, <b>ORDER</b> is also available.
E.g. to produce a salary rank for each employee according to his salary (the rank of '1' being assigned to the
highest salary), one can do a:
<pre>
SELECT emp_name, salary, RANK() OVER (ORDER BY salary DESC) AS sal_pos 
FROM test_curation.employee
ORDER BY sal_pos ASC
</pre>

(contrast the results, with those one gets when using <b>ROW_NUMBER()</b> instead of <b>RANK</b>)

This can allow us to obtain the three highest paid employees, where using the simpler <b>LIMIT</b>
clause of PostgreSQL would fail because of the tie on the third rank (Elizabeth and Flora).
The below simple approach shows only one of the two employees with a salary of 4:

<pre>
SELECT emp_name, salary
FROM test_curation.employee
ORDER BY salary DESC
LIMIT 3
</pre>

... whereas using the window function <b>RANK()</b> one is able to get both of them:

<pre>
SELECT x.* FROM (
SELECT emp_name, salary, rank() OVER (ORDER BY salary DESC) AS sal_pos 
FROM test_curation.employee
ORDER BY sal_pos ASC) x
WHERE x.sal_pos<=3
</pre>
<br/>
There is also the <b>DENSE_RANK()</b> function which continues counting, in case of ties, 
from the exactly previous rank (whereas <b>RANK()</b> in case of ties leaves a gap as wide
as the number of tied elements).

<li>Window functions rock!</li>
<pre>
DROP TABLE IF EXISTS test_curation.employee;
CREATE TABLE test_curation.employee (
department VARCHAR,
emp_name VARCHAR,
salary INTEGER);

INSERT INTO test_curation.employee(department, emp_name, salary) VALUES ('SALES', 'MIKE', 3);
INSERT INTO test_curation.employee(department, emp_name, salary) VALUES ('SALES', 'MARJORIE', 5);
INSERT INTO test_curation.employee(department, emp_name, salary) VALUES ('SALES', 'ELIZABETH', 4);
INSERT INTO test_curation.employee(department, emp_name, salary) VALUES ('SALES', 'FLORA', 4);
INSERT INTO test_curation.employee(department, emp_name, salary) VALUES ('DEV', 'THOMAS', 10);
INSERT INTO test_curation.employee(department, emp_name, salary) VALUES ('DEV', 'GEORGE', 2);
INSERT INTO test_curation.employee(department, emp_name, salary) VALUES ('DEV', 'MENELAUS', 1);

-- simple example to demonstrate the use of the window function AVG
SELECT department, emp_name, AVG(salary) OVER (PARTITION BY department), rank() OVER (PARTITION BY department ORDER BY salary DESC)
FROM test_curation.employee;

-- using the window function rank, observe that both Elizabeth and Flora appear as rank() assigns the same number
-- in case of ties
SELECT department, emp_name, salary, avg FROM
(SELECT department, emp_name, salary, AVG(salary) OVER (PARTITION BY department), rank() OVER (PARTITION BY department ORDER BY salary DESC)
FROM test_curation.employee) r
WHERE rank<=2;

-- rank() assigns the same number in case of ties() and also leaves gaps right after a tie:
SELECT department, emp_name, salary, avg FROM
(SELECT department, emp_name, salary, AVG(salary) OVER (PARTITION BY department), rank() OVER (PARTITION BY department ORDER BY salary DESC)
FROM test_curation.employee) r
WHERE rank=3;

-- row_number() always assigns different numbers and in case of a tie one row is chosen based on some arbitrary criterion (e.g. actual order fetched maybe?)
SELECT department, emp_name, salary, avg FROM
(SELECT department, emp_name, salary, AVG(salary) OVER (PARTITION BY department), row_number() OVER (PARTITION BY department ORDER BY salary DESC)
FROM test_curation.employee) r
WHERE row_number<=2;
</pre>
<li>PostgreSQL-specific way to get maximum or minimum values of certain columns for every combination of other columns</li>
This is using the PostgreSQL-specific <b>DISTINCT ON</b> syntax (an extension on the SQL standard <b>DISTINCT</b> for specific
columns).
<br>
Given the below table:
<pre>
CREATE TABLE A (A1 INTEGER, A2 INTEGER, A3 INTEGER);

INSERT INTO A(A1, A2, A3) VALUES (1, 1, 1);
INSERT INTO A(A1, A2, A3) VALUES (2, 1, 1);
INSERT INTO A(A1, A2, A3) VALUES (2, 1, 2);
INSERT INTO A(A1, A2, A3) VALUES (3, 1, 2);
INSERT INTO A(A1, A2, A3) VALUES (2, 1, 2);
INSERT INTO A(A1, A2, A3) VALUES (4, 1, 2);
INSERT INTO A(A1, A2, A3) VALUES (4, 1, 5);
INSERT INTO A(A1, A2, A3) VALUES (3, 1, 5);
</pre>
The following obtains minimum <b>a1</b> values for every combination of <b>a2</b> and <b>a3</b>:
<pre>
SELECT DISTINCT ON (a2, a3) a2, a3, a1 FROM A ORDER BY a2, a3, a1
</pre>
<br>Whereas the following does the same, for maximum <b>a1</b> values:
<pre>
SELECT DISTINCT ON (a2, a3) a2, a3, a1 FROM A ORDER BY a2, a3, a1 DESC
</pre>

<li>how to drop a database in PostgreSQL</li>
Three ways:
    <ol type="i">
        <li>command line only:</li>
        <pre>dropdb &ltdatabase name&gt</pre>
        <li>more refined, once connected as <i>postgres</i> superuser:</li>
        <pre>DROP DATABASE IF EXISTS &ltdatabase name&gt</pre>
        <li>the way above from the command line:</li>
        <pre>psql -U postgres postgres -f &ltfile with the above script&gt</pre>
    </ol>
<li>how to handle namespace prefixes in <b>xpath</b> queries</li>
Simple case (1 namespace prefix):
<pre>
SELECT ( CAST (xpath('/*/@xsi:type', content, array[array['xsi', 'http://www.w3.org/2001/XMLSchema-instance']]) AS TEXT[]))[1] from rr.resourcecontent
</pre>
<br/>More complicated case (2 namespace prefixes):
<pre>
SELECT ( CAST (xpath('/ri:Resource/@xsi:type', content, array[array['xsi', 'http://www.w3.org/2001/XMLSchema-instance'],
                                                              array['ri', 'http://www.ivoa.net/xml/RegistryInterface/v1.0']]) AS TEXT[]))[1] from rr.resourcecontent
</pre>
<li>another very useful syntax for doing <b>xpath</b> in PostgreSQL</li>
Basic idea is that we cast the xpath result to a text array and we take the first element (that's
when we know that the xpath expression will return a single value only):
<pre>
SELECT ( CAST (xpath('/*/identifier', content) AS TEXT[]))[1] from rr.resourcecontent
</pre>
<li>how to check if a value appears in an array</li>
The expression below evals to <b>true</b>
<pre>
select 'a' = ANY ('{a , b}'::varchar[])
</pre>
<li>how to use <b>xpath</b> in where clauses in PostgreSQL</li>
<b>xpath</b> types cannot be directly compared to string literals, so one has to do a cast, e.g.:
<pre>
select count(*) from rr.resourcecontent where cast (xpath('/*/capability/@standardID', content) as text[])='{ivo://ivoa.net/std/ConeSearch}'
</pre>
- or - <i>(to allow use of PostgreSQL <b>trim</b> function - but only if only one item is returned)</i>:
<pre>
select count(*) from rr.resourcecontent where trim( cast (xpath('/*/capability/@standardID', content) as text))='{ivo://ivoa.net/std/ConeSearch}'
</pre>
- or - <i>(if an array of values may be returned by the XPath expression)</i>:
<pre>
select count(*) from rr.resourcecontent where 'ivo://ivoa.net/std/ConeSearch' = ANY (cast (xpath('/*/capability/@standardID', content) as text[]) )
</pre>
(I haven't found a way how to cast to a text array <b>and</b> do a <b>trim()</b> at the same time).
<li>various types of inserts in PostgreSQL</li>
A good report comparing:
    <ol type=a>
    <li>VSI - very silly inserts (executing queries made by concatenated Strings, one-by-one)</li>
    <li>SPI - stupid prepared inserts (executing queries made by Prepared Inserts one-by-one)</li>
    <li>BPI - batch prepared inserts (executing queries made by Prepared Inserts in batches)</li>
    <li>CPI - copy inserts (using the 'properietary' COPY FROM API offered by PostgreSQL driver)</li>
    </ol>
</p> ... is given <a href="http://rostislav-matl.blogspot.com.es/2011/08/fast-inserts-to-postgresql-with-jdbc.html">here</a>.
Results graph is:</p><img src="inserts-linechart.png">
</p>My take is that BPIs are good enough without having to venture out onto non-standard CPI-land.
<br>Caveat: according to <a href="http://stackoverflow.com/questions/12012592/jdbc-insert-multiple-rows">this SO discussion</a>
auto commit should be set to false for 
BPI to offer any advantage over SPI (setting auto commit to false is one JDBC's best practices anyway).

<li>location of <b>pg_ctl</b> in Postgresql 9.2</li>
<pre>/usr/lib/postgresql/9.2/bin/pg_ctl</pre>
<li>NULL values in foreign key columns</li>
The following holds true at least in PostgreSQL 9.2:</p>
<a href="http://www.postgresql.org/message-id/200611200942.kAK9gwaK029065@wwwmaster.postgresql.org">source</a>
A FOREIGN KEY constraint does not have to be linked only to a PRIMARY KEY
constraint in another table; it can also be defined to reference the columns
of a UNIQUE constraint in another table. A FOREIGN KEY constraint can
contain null values; however, if any column of a composite FOREIGN KEY
constraint contains null values, verification of all values that make up the
FOREIGN KEY constraint is skipped. To make sure that all values of a
composite FOREIGN KEY constraint are verified, specify NOT NULL on all the
participating columns.
<li>how to log SQL statements in PostgreSQL 9.1</li>
<i>(see also <a href="http://stackoverflow.com/questions/722221/how-to-log-postgres-sql-queries">this SO discussion</a>)</i><p>
You have to change certain values in file <b>postgres.conf</b> and
restart the server.<p>
File <b>postgres.conf</b> is located in: <b>/etc/postgresql/9.1/main/postgresql.conf</b><p>
Diff of the changes I made is shown below:<p/>
<pre>
$ diff /etc/postgresql/9.1/main/postgresql.conf.safe.2012-01-15  /etc/postgresql/9.1/main/postgresql.conf
276c276
&lt #log_destination = 'stderr'# Valid values are combinations of
---
  &gt log_destination = 'stderr'# Valid values are combinations of
282c282
  &lt #logging_collector = off# Enable capturing of stderr and csvlog
---
    &gt logging_collector = on# Enable capturing of stderr and csvlog
288c288
    &lt #log_directory = 'pg_log'# directory where log files are written,
---
      &gt log_directory = 'pg_log'# directory where log files are written,
290c290
      &lt #log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'# log file name pattern,
---
        &gt log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'# log file name pattern,
398c398
        &lt #log_statement = 'none'# none, ddl, mod, all
---
          &gt log_statement = 'all'# none, ddl, mod, all

</pre>
The log directory (value <b>log_directory</b>) is located relative to the <i>data</i> folder of postgresql which is obtained as follows:<p/>
<pre>
$ grep -i data /etc/postgresql/9.1/main/postgresql.conf
# option or PGDATA environment variable, represented here as ConfigDir.
data_directory = '/var/lib/postgresql/9.1/main'# use data in another directory
</pre>
Once the server is restarted, the SQL queries (DDL and/or DML depending on the settings) can be obtained with:<p/>
<pre>
sudo -i
tail -f /var/lib/postgresql/9.1/main/pg_log/postgresql-2013-01-15_182646.log 
</pre>
<li>useful PostgreSQL functions:</li>
    <pre>
        select current_database();
        select current_schema();
        select current_user;
        select extract('epoch' from now());
         select extract('epoch' from current_timestamp);
        select now();
        select current_timestamp;
    </pre>
the last two are useful because they reveals the timezone.
<li>use of the command-line pg_dump utility:</li>
<pre> pg_dump &ltdatabase&gt -h 172.333.444.555 -p 5444 -U username -F p -E UTF8 -C -O -n %ltschema-name&gt -v -f dumpfile database-name</pre>
<li>precedence in PostgreSQL pg_hba.conf files</li>
The general rule of thumb is: <i>Most Specific Rule First</i>
<li>typical configuration of PostgreSQL 9.1 I am using:</li>
In file /etc/postgresql/9.1/main/pg_hba.conf:
<pre>
local   all             all                                 trust
host   all             all   192.168.2.2/24                 md5
</pre>
The rationale of <i>local trust</i> being to ensure that I can easily
add scripts to create users without the hassle of entering
passwords which is hard to do non-interactively. Remote accesses in
a specified subnet use <b>md5</b> authentication ofcourse.
<p>
And in file /etc/postgresql/9.1/main/postgresql.conf, to enable remote access:
<pre>listen_addresses = '*'</pre>
<pre>
listen_addresses = '*'
</pre>
<li>Configure PostgreSQL 9.1 to allow password access to users from a specific subdomain
(say 173.31.0.0/16, i.e. the 173.31 subdomain)</li>
<pre>
sudo-i
cd /etc/postgresql/9.1/main
</pre>
in pg_hba.conf add the following line:
<pre>
host all all 172.31.0.0/16 md5
</pre>
and in file postgresql.conf, change:
<pre>
listen_addresses='localhost'
</pre>
to:
<pre>
listen_addresses='*'
</pre>
<li>Configure PostgreSQL 9.1 to not require password for users</li><p>
This can be used, e.g. to automate the creation of users by means of a script.
Basically the following line has to be edited in the pg_hba.conf file:
<pre>
local   all              all                                trust
</pre>
For full reproducibility here's the full <a href="postgresql.html.folder/pg_hba.conf.html">pg_hba.conf</a> and the
<a href="postgresql.html.folder/postgresql.conf.html">postgresql.conf</a> configuration files.
(the second doesn't play any part in this solution and is just provided for completeness
purposes).
<li>Configure PostgreSQL 9.1 to accept remote connections</li><p>
<a href="http://www.cyberciti.biz/tips/postgres-allow-remote-access-tcp-connection.html">original article</a><p>
It's a two step process:
<ol type="i">
<li>enable client authentication</li>
Edit file /etc/postgresql/9.1/main/pg_hba.conf
and append the following configuration line to give access to the 192.168.2.0/24
network:
<pre>
host    all             all             192.168.2.0/24          md5
</pre>
<li>set the deamon to listen to the network interface</li>
Edit file /etc/postgresql/9.1/main/postgresql.conf and add the line:
<pre>
listen_addresses = '*'
</pre>
... to listen to all the network interfaces.
</ol>
After the above steps do a:
<pre>
sudo /etc/init.d/postgresql restart
</pre>
<li>Find Postgresql version</li>
Connect as an existing user to an existing database and run the "select version()" query, or from the command line:
<pre>
psql -Uhr -d ab -c 'select version()'
</pre>
</ol>


</body>
