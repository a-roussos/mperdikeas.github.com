<html>
<head>
<link type="text/css" rel="stylesheet" href="mperdikeasgithub.css"/>
<link type="text/css" rel="stylesheet" href="final-code-wavetheory-lightbox.css">
</head>
<body>
<ol reversed>
<li>list tags</li>
<pre>git tag -l</li>
<li>checkout remote tip</li>
<pre>git checkout origin/HEAD</pre>
<li>show remote tags</li>
<pre>git ls-remote --tags</pre>
<li>produce a git patch</li>
There are two ways:
    <ul>
        <li>using <b>git-format-patch</b>:</li>
        <pre> git format-patch 3266a7e </pre>
        (in the above example all changes between identified commit and the tip of the branch will be reported)
        <li>using <b>git-diff</b>:</li>
        I suspect the <i>tags</i> in the following can be any tree-ish objects:
        <pre>git diff 3266a7e 8deaaf2 > ~/lastchanges.patch</pre>
    </ul>
The <b>git-format-patch</b> method produces cleaner output.
<li>git add all files in a directory hierarchy except a particular one</li>
The following is the 'safe' version (echo):
<pre>find . ! -type d  ! -iname nosecurity_mvn.zip -exec echo git add {} \;</pre>
<li>examine tree-ish objects (such as commits)</li>
<pre>git ls-tree</pre> <p>or..<p>
<pre>git-ls-tree</pre><p>
This, and many other commands are available at /usr/lib/git-core
<li>show git tags including messages of annotated tags</li>
<pre>git tag -l -n1</pre>
<li>useful git log alias (to show tags among others)</li>
git config --global alias.lgb "log --graph --oneline --color --decorate"
<li>move local changes to new branch</li>
<pre>
git stash
git reset --hard
git clean -xf
git clean -df
git branch newBranch
git checkout newBranch
git stash pop
git add . -A -n
git commit -m "first commit on new branch"
</pre>
<li>change most recent git commit message</li>
<pre>git commit --amend -m "New commit message"</pre>
<li>concise, yet informative git history</li>
<p><pre>
git log --oneline --decorate=full --graph
</pre>
<li>how to init and fetch data for git submodules</li>
<p><pre>
git submodule init
git submodule update
</pre>
<li>how to get the hash of the current commit</u></b> (and just that)</li>
<p>
<pre>
git rev-parse --verify HEAD
</pre>
<p> - or simply -
<pre>
git rev-parse HEAD
</pre>
<li> how to restore a specific file to the branch's image:</li>
<pre>git checkout -f visualization "13 - COAST Caches/ccaches_protocol_types/src/org/coast/caches/network/types/CacheGetRequest.java"</pre>

In the incantation above 'visualization' (i.e. the branch name) is a tree-ish
object in git. The general signature of git checkout is therefore:
<pre>
git checkout <tree-ish> <optional path within the tree-ish>
</pre>

<li>overwrite local working copy modifications:</li>
                <pre>git checkout .</pre>
<li>bullet-proof way to reset all the files in the local repository:</li>
                <pre>
                $ git clean -d -x -f
                $ git reset --hard
                </pre>
                to just see which files will be deleted
                by git clean do a dry-run:
                <pre>
                $ git clean -d -x -n
                </pre>    
<li>how to check differences between local and remote branches:</li>
<pre>
                $ git diff master origin/master
</pre>
<li>to avoid having to type:</li>
<pre>
                git add . -A
                git commit -m " .. "
</pre>
                do a:
<pre>
                git config --global alias.ac '!git add . -A && git commit'
</pre>

<li>how to force git diff to always use color:</li>
<pre>
                git config --global color.diff auto
</pre>

<li>delete a commit that's also been pushed:</li>
<a href="http://stackoverflow.com/questions/1338728/how-to-delete-a-git-commit">source</a>
Assuming you are sitting on that commit, then this command will wack it...
<pre>
    git reset --hard HEAD~1
</pre>
The HEAD~1 means the commit before head.

Or, you could look at the output of git log, find the commit id of the commit you want to back up to, and then do this:
<pre>
    git reset --hard <sha1-commit-id>
</pre>
    If you already pushed it, you will need to do a force push to get rid of it...
<pre>
    git push origin HEAD --force
</pre>
However, if others may have pulled it, then you would be better off starting a new branch. Because when they pull, it will just merge it into their work, and you will get it pushed back up again.

If you already pushed, it may be better to use git revert, to create a <i>"mirror image"</i> commit that will undo the changes. However, both commits will both be in the log.

FYI -- git reset --hard HEAD is great if you want to get rid of WORK IN PROGRESS. It will reset you back to the most recent commit, and erase all the changes in your working tree and index.

Lastly, if you need to find a commit that you "deleted", it is typically present in git reflog unless you have garbage collected your repository.

comment:        
HEAD~1 or just HEAD^. If you pushed, you should use git revert instead
</ol>
</body>
</html>
