The toolchain for stress testing uses, at its core, the following tools:

(a) an HTTP proxy implemented in Python (file stressTestRecorder.py)
(b) a stress-test generator (file stressTestGenerator.py)
(c) the generated stress-tester.


The workflow is that the user spawns the proxy, sets up his browser to connect to it and then manually performs a scenario. Since the scenario uses the proxy, the HTTP proxy records all the requests sent by the browser and some minor information on the server's responses (to be compared against the responses when the test is run). The HTTP proxy doesn't change the requests sent by the browser except in two ways:
    [*] it only selects 'worthwhile' URLs from a short-list
    [*] it ignores some random HTTP GETs sent out by Chrome on startup (maybe related to the above)
    [*] it drops the http-proxy headers since, when we re-play the scenario we want the server to think that is's serving real browsers.
    [*] it drops the accept-encoding sent by the browsers when gzip is specified so it can search into the results sent by the server (to record that information).

The HTTP proxy records a 7-tuple for each browser request:
    [1] type of request (GET or POST)
    [2] URL
    [3] a tuple of the HTTP headers sent by the browser
    [4] a tuple of POST data (if any)
    [5] the timestamp (for the replay)
    [6] the title of the HTML page returned by the server (if present)
    [7] a JSF-specific value

Information is saved as a pickle file. To see a list of all the URLs visited (which are kept 
in the second element of the tuple, therefore on index 1), do a:

%<--------------------------------------------------
$ python
Python 2.7.3 (default, Jan  2 2013, 16:53:07)
[GCC 4.7.2] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> import cPickle
>>> a=cPickle.load(open('loginLogout.scenario'))
>>> print '\n'.join(repr(x[1]) for x in a) 
-------------------------------------------------->%

Then, the stress-test generator runs on the recorded pickle and produces a Python stress tester that hard-coded replays the sequence of HTTP requests captured by the recorded either with or without delays and with a configurable number of threads.

Finally, as a finishing touch, there is Sikuli script / robot that records the clicks done by the user so he doesn't have to repeat them if a new recording is required. In a JSF application a reason for requiring a re-recording might by a re-deployment in the application server, as when that happens the identifiers generated by JSF are changed so the headers and everything need to be re-recorded.


